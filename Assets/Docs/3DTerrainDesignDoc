ハイブリッド・ボクセル地形生成システム 開発仕様書1. プロジェクト概要既存の2Dハイトマップ地形システムを拡張し、洞窟、オーバーハング、浮遊島を含む3次元的な地形生成を可能にするシステムを構築する。ベース地形の制御しやすさ（2Dハイトマップ）と、複雑な形状表現（3Dボクセル）を両立するため、**「マーチングキューブ法を用いたハイブリッドSDF生成」**を採用する。2. 技術スタック & 要件Engine: Unity (バージョン指定: 2022.3 LTS以降推奨)Language: C#Core Algorithm: Marching Cubes (または Dual Contouring)Optimization: Unity Job System + Burst Compiler (必須)Rendering: Standard Shader / URP / HDRP (Triplanar Mapping対応)3. システムアーキテクチャシステムは以下の3つの入力を合成し、単一のメッシュを出力する。Base Terrain (2D): 既存のハイトマップ（または2D Perlin Noise）。地面の基本高さを決定。Cave Network (3D): 3D Perlin Noise。地下空洞を自動生成するためのマスク。Features (SDF Stamps): 3Dテクスチャとして取り込まれたSDFデータ。特定の部屋や岩などを配置。4. アルゴリズム詳細定義AIに対する最も重要な指示書です。密度関数（Density Function）の計算式を定義します。4.1 密度関数 (Density Calculation)空間上の任意の座標 $P(x, y, z)$ における密度 $D$ を以下のロジックで計算する。$D > 0$: 地面（実体）$D < 0$: 空気（空洞）計算式:$$D_{final} = \text{OpSubtract}(\text{OpUnion}(D_{base}, D_{stamp}), D_{cave})$$各項の定義:ベース地形 ($D_{base}$):$$D_{base} = \text{HeightMap}(x, z) - y$$※ $y$ がハイトマップより低い場所ほど正の値（土）になり、高い場所ほど負の値（空）になる。洞窟ノイズ ($D_{cave}$):$$D_{cave} = \text{PerlinNoise3D}(x \times scale, y \times scale, z \times scale) - \text{Threshold}$$SDFスタンプ ($D_{stamp}$):ワールド座標をスタンプのローカル座標に変換し、3Dテクスチャからサンプリングした値を加算（またはSmoothUnion）する。4.2 メッシュ生成 (Meshing)空間をチャンク（例: 16x16x16 または 32x32x32）に分割する。Job Systemを使用して、各グリッドポイントの密度 $D_{final}$ を並列計算する。マーチングキューブ法を用いて、等値面（Iso-surface, $D=0$）のメッシュを生成する。5. 実装ステップ（AIへの指示用）AIに対しては、一度に全て生成させず、以下のフェーズごとにコードを書かせることを推奨します。Phase 1: 高速なマーチングキューブの基盤作成Prompt:Unity C#にて、Job SystemとBurst Compilerを使用した最適化された「マーチングキューブ」のメッシュ生成スクリプトを作成してください。入力は NativeArray<float> の密度データ、出力は Mesh です。まずはテスト用として、単純な球体のSDF（radius - distance）を表示できるか確認してください。Phase 2: ハイトマップとの合成Prompt:Phase 1の密度計算部分を拡張します。2Dのパーリンノイズ（Mathf.PerlinNoise）をハイトマップとして見立て、density = noise_height(x, z) - y という計算式で、疑似的な地形を生成するように変更してください。これにより、上空は空気、地面より下は土として判定されるはずです。Phase 3: 3Dノイズによる洞窟の掘削Prompt:さらに密度関数を拡張し、3Dノイズによる「洞窟生成」を追加してください。density から 3D Perlin Noise の値を減算（またはBoolean Subtract）し、地下に空洞ができるようにしてください。ノイズの閾値を調整可能なパラメータとして公開してください。Phase 4: SDFスタンプ（3Dテクスチャ）の実装Prompt:「SDFスタンプ」機能を実装します。Texture3D アセットをSDFデータとして読み込む仕組みを作ってください。任意のワールド座標と回転にこのスタンプを配置できるようにしてください。密度計算Jobの中で、スタンプのバウンディングボックス内に座標がある場合、3Dテクスチャの値をサンプリングして密度に加算（Union）してください。Phase 5: テクスチャリング (Triplanar)Prompt:生成されたメッシュ用のシェーダーを作成してください。UV展開が不要な「Triplanar Mapping」を使用し、側面の法線には岩のテクスチャ、上面の法線には草のテクスチャがブレンドされるようにしてください。Standard Surface Shader または Shader Graph で作成してください。6. データ構造と最適化戦略AIに以下のクラス設計を守らせてください。VoxelChunk:Vector3Int coordinate: チャンク座標GenerateMesh(): メッシュ更新のエントリーポイントVoxelWorld:Dictionary<Vector3Int, VoxelChunk>: チャンク管理プレイヤーの位置に応じて動的にチャンクを生成・破棄するプーリングシステム。SDFStampData:Texture3D texture: 形状データfloat size: スケールfloat blendFactor: 地形との融合の滑らかさAIへの最初のプロンプト例（コピペ用）上記の仕様を元に、開発をスタートするための最初のプロンプトです。MarkdownあなたはUnityの熟練したグラフィックスエンジニアです。
以下の要件に基づき、ハイブリッドなボクセル地形生成システムのプロトタイプを作成したいと考えています。

# 要件
1. アルゴリズム: Marching Cubes
2. 技術: Unity C#, Job System, Burst Compiler (必須)
3. ゴール:
   - 2Dハイトマップ（単純なPerlinノイズで代用可）をベースにした地形を生成する。
   - その地形に対して、3Dノイズを使って「洞窟」をくり抜く処理を入れる。
   - 高速に動作させるため、計算は全てJob内で行う。

まず、この要件を満たすための「VoxelGenerator」クラスと、密度計算を行う「DensityJob」構造体のコードを提示してください。
補足：SDFスタンプ用データの作り方AIにコードを書かせている間に、テスト用の3Dテクスチャを用意する必要があります。Unityアセットストアで "Mesh to SDF" 系のツール（無料のものや安価なもの）を入手し、単純なSphereやCubeのメッシュを3Dテクスチャに変換しておくと、Phase 4ですぐにテストが可能です。この仕様書の手順で進めれば、既存のハイトマップの知識を活かしつつ、洞窟やオーバーハングのある次世代的な地形システムが確実に構築できます。