# 作業記録 05: Phase 5 高度合成システム設計

## 2025-10-23: 高度合成システム設計（Phase 5開始）

### 概要
複数地形タイプの合成ロジック設計を開始。現在の単一地形生成システムを拡張し、異なる地形タイプ（山岳、平原、峡谷など）の合成を可能にする高度なシステムを設計する。

### 設計要件分析
#### 現在の地形生成システムの問題点
- **単一タイプ依存**: 現在のシステムは1つの地形タイプのみ生成可能
- **合成ロジック欠如**: 異なる地形タイプ間の自然な遷移がない
- **スケーラビリティ不足**: 大規模地図での多様な地形表現が困難

#### 高度合成システムの目標
- **複数地形タイプ対応**: 山岳、平原、峡谷、湖、森林などの合成
- **自然な遷移**: 地形タイプ間の境界を自然にブレンド
- **パフォーマンス最適化**: 大規模マップでも効率的な生成
- **拡張性**: 新しい地形タイプの容易な追加

### アーキテクチャ設計
#### TerrainType システム
```csharp
public enum TerrainType
{
    Mountain,    // 山岳地形
    Plain,       // 平原
    Valley,      // 峡谷
    Lake,        // 湖
    Forest,      // 森林
    Desert,      // 砂漠
    Coast        // 海岸
}

public class TerrainTypeDefinition
{
    public TerrainType Type;
    public float BaseHeight;
    public float HeightVariation;
    public float NoiseScale;
    public Color BaseColor;
    public Material TerrainMaterial;
}
```

#### TerrainSynthesizer クラス設計
```csharp
public class TerrainSynthesizer : MonoBehaviour
{
    [Header("合成設定")]
    [SerializeField] private TerrainType dominantType = TerrainType.Plain;
    [SerializeField] private List<TerrainTypeDefinition> availableTypes;
    [SerializeField] private float blendRadius = 100f;
    [SerializeField] private AnimationCurve blendCurve;

    [Header("生成パラメータ")]
    [SerializeField] private int resolution = 256;
    [SerializeField] private float terrainSize = 1000f;
    [SerializeField] private int seed = 42;

    // 合成ロジック
    private Dictionary<Vector2Int, TerrainType> terrainMap;
    private Dictionary<TerrainType, TerrainTypeDefinition> typeDefinitions;

    public void GenerateSynthesizedTerrain()
    {
        // 1. 地形タイプ分布の生成
        GenerateTerrainTypeDistribution();

        // 2. 各タイプの地形データ生成
        GenerateIndividualTerrainData();

        // 3. 合成とブレンド処理
        SynthesizeTerrainData();

        // 4. 最終地形の適用
        ApplySynthesizedTerrain();
    }
}
```

#### 合成アルゴリズム設計
##### 1. 地形タイプ分布生成
- **ウォロノイ図ベース**: 各ポイントを地形タイプの中心として領域分割
- **ノイズベース**: パーリンノイズで自然な分布生成
- **ヒートマップ**: 距離ベースの影響度計算

##### 2. ブレンド処理
- **線形補間**: シンプルな境界ブレンド
- **曲線ブレンド**: AnimationCurveを使用した自然な遷移
- **複数タイプ合成**: 3つ以上の地形タイプの交差点処理

##### 3. 最適化戦略
- **チャンクベース処理**: 大規模マップを分割処理
- **LODシステム**: 距離に応じた詳細度調整
- **非同期生成**: バックグラウンドでの地形生成

### UI統合設計
#### TerrainTypeSelector UI
```csharp
public class TerrainTypeSelector : Vastcore.UI.ModernUIManager
{
    [Header("地形タイプ選択")]
    [SerializeField] private List<TerrainTypeButton> typeButtons;
    [SerializeField] private Vastcore.UI.SliderBasedUISystem parameterSliders;

    public void OnTerrainTypeSelected(TerrainType selectedType)
    {
        // 選択された地形タイプのパラメータをUIに反映
        UpdateParameterUI(selectedType);
    }

    public void OnParameterChanged(string parameterName, float value)
    {
        // パラメータ変更をTerrainSynthesizerに通知
        terrainSynthesizer.UpdateParameter(parameterName, value);
    }
}
```

### 実装計画
#### Phase 5.1: 基礎システム実装
- TerrainType 列挙型と定義クラスの作成
- TerrainSynthesizer の基本構造実装
- シンプルな2タイプ合成の実装

#### Phase 5.2: 高度合成機能
- 複数タイプの同時合成
- 高度なブレンドアルゴリズム
- パフォーマンス最適化

#### Phase 5.3: UI統合
- TerrainTypeSelector の実装
- パラメータ調整UIの実装
- リアルタイムプレビュー機能

### 技術的考慮事項
- **メモリ管理**: 大規模合成時のメモリ使用量最適化
- **パフォーマンス**: 合成処理のCPU/GPU使用バランス
- **スケーラビリティ**: 地形サイズに応じたアルゴリズム調整
- **互換性**: 既存の地形生成システムとの統合

### 次のステップ
- TerrainType 定義の詳細設計
- 基本的な合成アルゴリズムの実装開始
- UI統合のプロトタイプ作成
